use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::{env, fs};

/// Parses a `.mk` file containing variable assignments of the form:
/// ```text
/// VAR_NAME = \
///   file1.c \
///   file2.c
/// ```
/// Returns a map of variable names to lists of file paths.
fn parse_mk_file(path: &Path) -> HashMap<String, Vec<String>> {
    let text = fs::read_to_string(path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {}", path.display(), e));
    let text = text.replace("\\\n", " ");
    text.lines()
        .filter(|l| l.contains('='))
        .map(|l| {
            let (key, values) = l.split_once('=').unwrap();
            (
                key.trim().to_string(),
                values.split_whitespace().map(String::from).collect(),
            )
        })
        .collect()
}

/// Reads a named variable from a parsed `.mk` file, panicking if not found.
fn get_sources(mk: &HashMap<String, Vec<String>>, var: &str) -> Vec<String> {
    mk.get(var)
        .unwrap_or_else(|| panic!("Variable {} not found in .mk file", var))
        .clone()
}

const OPUS_INCLUDES: &[&str] = &[".", "include", "celt", "silk", "silk/float"];

const CONFIG_H: &str = r##"
/* config.h — generated by libopus-sys build.rs */

#define ENABLE_HARDENING 1
#define HAVE_DLFCN_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_LRINT 1
#define HAVE_LRINTF 1
#define HAVE_STDINT_H 1
#define HAVE_STDIO_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRINGS_H 1
#define HAVE_STRING_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_UNISTD_H 1
#define LT_OBJDIR ".libs/"
#define OPUS_BUILD
#define PACKAGE_BUGREPORT "opus@xiph.org"
#define PACKAGE_NAME "opus"
#define PACKAGE_STRING "opus 1.3.1"
#define PACKAGE_TARNAME "opus"
#define PACKAGE_URL ""
#define PACKAGE_VERSION "1.3.1"
#define STDC_HEADERS 1
#define VAR_ARRAYS 1

#define restrict __restrict
#if defined __SUNPRO_CC && !defined __RESTRICT
# define _Restrict
# define __restrict__
#endif
"##;

/// Generates a new binding at `src/lib.rs` using `src/wrapper.h`.
#[cfg(feature = "generate_binding")]
fn generate_binding() {
    const ALLOW_UNCONVENTIONALS: &str = "#![allow(non_upper_case_globals)]\n\
                                         #![allow(non_camel_case_types)]\n\
                                         #![allow(non_snake_case)]\n";

    let bindings = bindgen::Builder::default()
        .header("src/wrapper.h")
        .raw_line(ALLOW_UNCONVENTIONALS)
        .generate()
        .expect("Unable to generate binding");

    let binding_target_path = PathBuf::new().join("src").join("lib.rs");

    bindings
        .write_to_file(binding_target_path)
        .expect("Could not write binding to the file at `src/lib.rs`");
}

fn build_opus() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR not set"));
    let opus_build_dir = out_dir.join("opus_build");
    let opus_build_src_dir = out_dir.join("opus_src");
    let opus_source_path = Path::new("opus");

    // Parse upstream .mk files for source and header lists
    let opus_sources_mk = parse_mk_file(&opus_source_path.join("opus_sources.mk"));
    let celt_sources_mk = parse_mk_file(&opus_source_path.join("celt_sources.mk"));
    let silk_sources_mk = parse_mk_file(&opus_source_path.join("silk_sources.mk"));
    let opus_headers_mk = parse_mk_file(&opus_source_path.join("opus_headers.mk"));
    let celt_headers_mk = parse_mk_file(&opus_source_path.join("celt_headers.mk"));
    let silk_headers_mk = parse_mk_file(&opus_source_path.join("silk_headers.mk"));

    // Collect source files to compile (float mode, no SIMD/platform intrinsics)
    let mut sources: Vec<String> = Vec::new();
    sources.extend(get_sources(&opus_sources_mk, "OPUS_SOURCES"));
    sources.extend(get_sources(&opus_sources_mk, "OPUS_SOURCES_FLOAT"));
    sources.extend(get_sources(&celt_sources_mk, "CELT_SOURCES"));
    sources.extend(get_sources(&silk_sources_mk, "SILK_SOURCES"));
    sources.extend(get_sources(&silk_sources_mk, "SILK_SOURCES_FLOAT"));

    // Collect header files for dependency tracking
    let mut headers: Vec<String> = Vec::new();
    headers.extend(get_sources(&opus_headers_mk, "OPUS_HEAD"));
    headers.extend(get_sources(&celt_headers_mk, "CELT_HEAD"));
    headers.extend(get_sources(&silk_headers_mk, "SILK_HEAD"));

    // Clean build directories
    if opus_build_src_dir.exists() {
        fs::remove_dir_all(&opus_build_src_dir).expect("Could not remove build directory");
    }
    if opus_build_dir.exists() {
        fs::remove_dir_all(&opus_build_dir).expect("Could not remove build directory");
    }

    // Copy source and header files to the build directory
    for source in sources.iter().chain(headers.iter()) {
        let source_path = opus_source_path.join(source);
        let target_path = opus_build_src_dir.join(source);

        fs::create_dir_all(
            target_path
                .parent()
                .expect("Could not get parent directory"),
        )
        .expect("Could not create target directory");

        if source_path.exists() {
            fs::copy(&source_path, &target_path).expect("Could not copy source file");
        }
        // Some headers listed in .mk files are platform-specific and may not exist
        // in our vendored source (e.g. arm/, mips/ headers). That's fine — they're
        // only needed when compiling with those platform intrinsics enabled.
    }

    // Write config.h
    fs::write(opus_build_src_dir.join("config.h"), CONFIG_H).expect("Could not write config.h");

    let mut build = cc::Build::new();
    build
        .std("c11")
        .includes(
            OPUS_INCLUDES
                .iter()
                .map(|path| opus_build_src_dir.join(path)),
        )
        .files(sources.iter().map(|source| opus_build_src_dir.join(source)))
        .define("HAVE_CONFIG_H", "1")
        .out_dir(&opus_build_dir);

    // Disable FMA fusion and other FP trickery that Rust doesn't do.
    // Important for reproducible bit-exact output on FMA-capable CPUs (like Arm64).
    let compiler = build.get_compiler();
    if compiler.is_like_clang() || compiler.is_like_gnu() {
        build.flag("-ffp-contract=off");
    }
    if compiler.is_like_clang() {
        build.flag("-ffp-model=strict");
    }
    if compiler.is_like_msvc() {
        build.flag("/fp:strict");
    }

    // On 32-bit x86, the default C compiler uses x87 FPU (80-bit extended precision)
    // while Rust uses SSE2 (strict 32/64-bit precision). This mismatch causes
    // different float results. Force SSE2 math to match Rust's behavior.
    let target = env::var("TARGET").unwrap_or_default();
    if (target.starts_with("i686") || target.starts_with("i586"))
        && (compiler.is_like_clang() || compiler.is_like_gnu())
    {
        build.flag("-msse2");
        build.flag("-mfpmath=sse");
    }

    build.compile("opus");

    // Link
    println!("cargo:rustc-link-lib=static=opus");
    println!(
        "cargo:rustc-link-search=native={}",
        opus_build_dir.display()
    );

    // Re-run on any changes to sources, headers, or .mk files
    for source in sources.iter().chain(headers.iter()) {
        println!(
            "cargo:rerun-if-changed={}",
            opus_source_path.join(source).display()
        );
    }
    for mk_file in &[
        "opus_sources.mk",
        "opus_headers.mk",
        "celt_sources.mk",
        "celt_headers.mk",
        "silk_sources.mk",
        "silk_headers.mk",
    ] {
        println!(
            "cargo:rerun-if-changed={}",
            opus_source_path.join(mk_file).display()
        );
    }
}

fn main() {
    #[cfg(feature = "generate_binding")]
    generate_binding();

    build_opus();
}
