use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::{env, fs};

/// Parses a `.mk` file containing variable assignments of the form:
/// ```text
/// VAR_NAME = \
///   file1.c \
///   file2.c
/// ```
/// Returns a map of variable names to lists of file paths.
fn parse_mk_file(path: &Path) -> HashMap<String, Vec<String>> {
    let text = fs::read_to_string(path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {}", path.display(), e));
    let text = text.replace("\\\r\n", " ").replace("\\\n", " ");
    text.lines()
        .filter(|l| l.contains('='))
        .map(|l| {
            let (key, values) = l.split_once('=').unwrap();
            (
                key.trim().to_string(),
                values.split_whitespace().map(String::from).collect(),
            )
        })
        .collect()
}

/// Reads a named variable from a parsed `.mk` file, panicking if not found.
fn get_sources(mk: &HashMap<String, Vec<String>>, var: &str) -> Vec<String> {
    mk.get(var)
        .unwrap_or_else(|| panic!("Variable {} not found in .mk file", var))
        .clone()
}

const OPUS_INCLUDES: &[&str] = &[
    ".",
    "include",
    "celt",
    "silk",
    "silk/float",
    "silk/fixed",
    "dnn",
];

const CONFIG_H: &str = r##"
/* config.h — generated by libopus-sys build.rs */

#define ENABLE_HARDENING 1
#define HAVE_DLFCN_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_LRINT 1
#define HAVE_LRINTF 1
#define HAVE_STDINT_H 1
#define HAVE_STDIO_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRINGS_H 1
#define HAVE_STRING_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_UNISTD_H 1
#define LT_OBJDIR ".libs/"
#define OPUS_BUILD
#define PACKAGE_BUGREPORT "opus@xiph.org"
#define PACKAGE_NAME "opus"
#define PACKAGE_STRING "opus 1.5.2"
#define PACKAGE_TARNAME "opus"
#define PACKAGE_URL ""
#define PACKAGE_VERSION "1.5.2"
#define STDC_HEADERS 1
#define VAR_ARRAYS 1

#define restrict __restrict
#if defined __SUNPRO_CC && !defined __RESTRICT
# define _Restrict
# define __restrict__
#endif
"##;

/// Generates a new binding at `src/lib.rs` using `src/wrapper.h`.
#[cfg(feature = "generate_binding")]
fn generate_binding() {
    const ALLOW_UNCONVENTIONALS: &str = "#![allow(non_upper_case_globals)]\n\
                                         #![allow(non_camel_case_types)]\n\
                                         #![allow(non_snake_case)]\n";

    let bindings = bindgen::Builder::default()
        .header("src/wrapper.h")
        .raw_line(ALLOW_UNCONVENTIONALS)
        .generate()
        .expect("Unable to generate binding");

    let binding_target_path = PathBuf::new().join("src").join("lib.rs");

    bindings
        .write_to_file(binding_target_path)
        .expect("Could not write binding to the file at `src/lib.rs`");
}

fn build_opus() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR not set"));
    let opus_build_dir = out_dir.join("opus_build");
    let opus_build_src_dir = out_dir.join("opus_src");
    let opus_source_path = Path::new("opus");

    let deep_plc = env::var("CARGO_FEATURE_DEEP_PLC").is_ok();
    let dred = env::var("CARGO_FEATURE_DRED").is_ok();
    let osce = env::var("CARGO_FEATURE_OSCE").is_ok();

    // Parse upstream .mk files for source and header lists
    let opus_sources_mk = parse_mk_file(&opus_source_path.join("opus_sources.mk"));
    let celt_sources_mk = parse_mk_file(&opus_source_path.join("celt_sources.mk"));
    let silk_sources_mk = parse_mk_file(&opus_source_path.join("silk_sources.mk"));
    let opus_headers_mk = parse_mk_file(&opus_source_path.join("opus_headers.mk"));
    let celt_headers_mk = parse_mk_file(&opus_source_path.join("celt_headers.mk"));
    let silk_headers_mk = parse_mk_file(&opus_source_path.join("silk_headers.mk"));

    let simd = cfg!(feature = "simd");

    // Collect source files to compile (float mode)
    let mut sources: Vec<String> = Vec::new();
    // Extra sources that live outside the upstream tree (abs_path, relative_dest).
    let mut extra_sources: Vec<(PathBuf, PathBuf)> = Vec::new();
    sources.extend(get_sources(&opus_sources_mk, "OPUS_SOURCES"));
    sources.extend(get_sources(&opus_sources_mk, "OPUS_SOURCES_FLOAT"));
    sources.extend(get_sources(&celt_sources_mk, "CELT_SOURCES"));
    sources.extend(get_sources(&silk_sources_mk, "SILK_SOURCES"));
    sources.extend(get_sources(&silk_sources_mk, "SILK_SOURCES_FLOAT"));

    // Parse lpcnet_sources.mk early so it's accessible in the SIMD block
    let lpcnet_sources_mk = if deep_plc {
        Some(parse_mk_file(&opus_source_path.join("lpcnet_sources.mk")))
    } else {
        None
    };

    // SIMD source groups — compiled with per-file flags later
    let mut simd_groups: Vec<(Vec<String>, &str)> = Vec::new(); // (sources, arch_flag)

    if simd {
        let target_arch = env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_default();

        if target_arch == "x86_64" || target_arch == "x86" {
            // RTCD (runtime CPU detection) sources — no special flags
            sources.extend(get_sources(&celt_sources_mk, "CELT_SOURCES_X86_RTCD"));
            sources.extend(get_sources(&silk_sources_mk, "SILK_SOURCES_X86_RTCD"));

            // SIMD sources with per-group compiler flags
            simd_groups.push((get_sources(&celt_sources_mk, "CELT_SOURCES_SSE"), "-msse"));
            simd_groups.push((get_sources(&celt_sources_mk, "CELT_SOURCES_SSE2"), "-msse2"));
            simd_groups.push((
                get_sources(&celt_sources_mk, "CELT_SOURCES_SSE4_1"),
                "-msse4.1",
            ));
            simd_groups.push((
                get_sources(&silk_sources_mk, "SILK_SOURCES_SSE4_1"),
                "-msse4.1",
            ));
            simd_groups.push((
                get_sources(&celt_sources_mk, "CELT_SOURCES_AVX2"),
                "-mavx2 -mfma",
            ));
            simd_groups.push((get_sources(&silk_sources_mk, "SILK_SOURCES_AVX2"), "-mavx2"));
            simd_groups.push((
                get_sources(&silk_sources_mk, "SILK_SOURCES_FLOAT_AVX2"),
                "-mavx2 -mfma",
            ));
            if let Some(ref lpcnet_mk) = lpcnet_sources_mk {
                sources.extend(get_sources(lpcnet_mk, "DNN_SOURCES_X86_RTCD"));
                simd_groups.push((get_sources(lpcnet_mk, "DNN_SOURCES_SSE2"), "-msse2"));
                simd_groups.push((get_sources(lpcnet_mk, "DNN_SOURCES_SSE4_1"), "-msse4.1"));
                simd_groups.push((get_sources(lpcnet_mk, "DNN_SOURCES_AVX2"), "-mavx2 -mfma"));
            }
        } else if target_arch == "aarch64" {
            // RTCD sources
            sources.extend(get_sources(&celt_sources_mk, "CELT_SOURCES_ARM_RTCD"));
            sources.extend(get_sources(&silk_sources_mk, "SILK_SOURCES_ARM_RTCD"));

            // NEON intrinsics (always available on aarch64, no extra flags needed)
            sources.extend(get_sources(&celt_sources_mk, "CELT_SOURCES_ARM_NEON_INTR"));
            sources.extend(get_sources(&silk_sources_mk, "SILK_SOURCES_ARM_NEON_INTR"));
            if let Some(ref lpcnet_mk) = lpcnet_sources_mk {
                sources.extend(get_sources(lpcnet_mk, "DNN_SOURCES_ARM_RTCD"));
                sources.extend(get_sources(lpcnet_mk, "DNN_SOURCES_NEON"));
                simd_groups.push((
                    get_sources(lpcnet_mk, "DNN_SOURCES_DOTPROD"),
                    "-march=armv8.2-a+dotprod",
                ));
            }
        }
    }

    // Collect header files for dependency tracking
    let mut headers: Vec<String> = Vec::new();
    headers.extend(get_sources(&opus_headers_mk, "OPUS_HEAD"));
    headers.extend(get_sources(&celt_headers_mk, "CELT_HEAD"));
    headers.extend(get_sources(&silk_headers_mk, "SILK_HEAD"));

    // DNN sources and headers (feature-gated)
    if deep_plc {
        let lpcnet_sources_mk = lpcnet_sources_mk
            .unwrap_or_else(|| parse_mk_file(&opus_source_path.join("lpcnet_sources.mk")));
        let lpcnet_headers_mk = parse_mk_file(&opus_source_path.join("lpcnet_headers.mk"));

        sources.extend(get_sources(&lpcnet_sources_mk, "DEEP_PLC_SOURCES"));
        headers.extend(get_sources(&lpcnet_headers_mk, "DEEP_PLC_HEAD"));

        // Our helper that serializes compiled-in weight arrays to the blob format.
        // Lives in libopus-sys/src/ (not in the upstream opus tree).
        // We copy it into the build dir's dnn/ alongside the upstream sources.
        extra_sources.push((
            PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("src/write_weights_blob.c"),
            PathBuf::from("dnn/write_weights_blob.c"),
        ));

        if dred {
            sources.extend(get_sources(&lpcnet_sources_mk, "DRED_SOURCES"));
            headers.extend(get_sources(&lpcnet_headers_mk, "DRED_HEAD"));
        }
        if osce {
            sources.extend(get_sources(&lpcnet_sources_mk, "OSCE_SOURCES"));
            headers.extend(get_sources(&lpcnet_headers_mk, "OSCE_HEAD"));

            extra_sources.push((
                PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("src/osce_test_harness.c"),
                PathBuf::from("dnn/osce_test_harness.c"),
            ));
        }
    }

    // Clean build directories
    if opus_build_src_dir.exists() {
        fs::remove_dir_all(&opus_build_src_dir).expect("Could not remove build directory");
    }
    if opus_build_dir.exists() {
        fs::remove_dir_all(&opus_build_dir).expect("Could not remove build directory");
    }

    // Copy source and header files to the build directory
    for source in sources.iter().chain(headers.iter()) {
        let source_path = opus_source_path.join(source);
        let target_path = opus_build_src_dir.join(source);

        fs::create_dir_all(
            target_path
                .parent()
                .expect("Could not get parent directory"),
        )
        .expect("Could not create target directory");

        if source_path.exists() {
            fs::copy(&source_path, &target_path).expect("Could not copy source file");
        }
        // Some headers listed in .mk files are platform-specific and may not exist
        // in our vendored source (e.g. arm/, mips/ headers). That's fine — they're
        // only needed when compiling with those platform intrinsics enabled.
    }

    // Copy extra (non-upstream) sources into the build dir and register them.
    for (abs_src, rel_dest) in &extra_sources {
        let target_path = opus_build_src_dir.join(rel_dest);
        fs::create_dir_all(target_path.parent().unwrap())
            .expect("Could not create target directory");
        fs::copy(abs_src, &target_path).expect("Could not copy extra source file");
        sources.push(rel_dest.to_string_lossy().into_owned());
    }

    // Write config.h with optional DNN and SIMD defines
    let mut config = CONFIG_H.to_string();
    if deep_plc {
        config.push_str("#define ENABLE_DEEP_PLC 1\n");
    }
    if dred {
        config.push_str("#define ENABLE_DRED 1\n");
    }
    if osce {
        config.push_str("#define ENABLE_OSCE 1\n");
    }

    if simd {
        let target_arch = env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_default();

        if target_arch == "x86_64" || target_arch == "x86" {
            config.push_str("#define OPUS_X86_MAY_HAVE_SSE 1\n");
            config.push_str("#define OPUS_X86_MAY_HAVE_SSE2 1\n");
            config.push_str("#define OPUS_X86_MAY_HAVE_SSE4_1 1\n");
            config.push_str("#define OPUS_X86_MAY_HAVE_AVX2 1\n");
            config.push_str("#define OPUS_HAVE_RTCD 1\n");
            // CPUID detection method for runtime CPU feature detection
            let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap_or_default();
            if target_os == "windows" {
                // MSVC uses __cpuid intrinsic from <intrin.h> (handled in x86cpu.c)
            } else {
                // GCC/Clang: use __get_cpuid from <cpuid.h>
                config.push_str("#define CPU_INFO_BY_C 1\n");
            }
        } else if target_arch == "aarch64" {
            config.push_str("#define OPUS_ARM_MAY_HAVE_NEON_INTR 1\n");
            config.push_str("#define OPUS_ARM_ASM 1\n");
            config.push_str("#define OPUS_ARM_MAY_HAVE_DOTPROD 1\n");
            config.push_str("#define OPUS_HAVE_RTCD 1\n");
        }
    }

    fs::write(opus_build_src_dir.join("config.h"), config).expect("Could not write config.h");

    let mut build = cc::Build::new();
    build
        .std("c11")
        .includes(
            OPUS_INCLUDES
                .iter()
                .map(|path| opus_build_src_dir.join(path)),
        )
        .files(sources.iter().map(|source| opus_build_src_dir.join(source)))
        .define("HAVE_CONFIG_H", "1")
        .out_dir(&opus_build_dir);

    // Disable FMA fusion and other FP trickery that Rust doesn't do.
    // Important for reproducible bit-exact output on FMA-capable CPUs (like Arm64).
    let compiler = build.get_compiler();
    if compiler.is_like_clang() || compiler.is_like_gnu() {
        build.flag("-ffp-contract=off");
    }
    if compiler.is_like_clang() {
        build.flag("-ffp-model=strict");
    }
    if compiler.is_like_msvc() {
        build.flag("/fp:strict");
    }

    // On 32-bit x86, the default C compiler uses x87 FPU (80-bit extended precision)
    // while Rust uses SSE2 (strict 32/64-bit precision). This mismatch causes
    // different float results. Force SSE2 math to match Rust's behavior.
    let target = env::var("TARGET").unwrap_or_default();
    if (target.starts_with("i686") || target.starts_with("i586"))
        && (compiler.is_like_clang() || compiler.is_like_gnu())
    {
        build.flag("-msse2");
        build.flag("-mfpmath=sse");
    }

    build.compile("opus");

    // Compile SIMD source groups with per-group arch flags
    for (i, (simd_sources, arch_flags)) in simd_groups.iter().enumerate() {
        let mut simd_build = cc::Build::new();
        simd_build
            .std("c11")
            .includes(
                OPUS_INCLUDES
                    .iter()
                    .map(|path| opus_build_src_dir.join(path)),
            )
            .define("HAVE_CONFIG_H", "1")
            .out_dir(&opus_build_dir);

        // Copy the same FP and platform flags
        let compiler = simd_build.get_compiler();
        if compiler.is_like_clang() || compiler.is_like_gnu() {
            simd_build.flag("-ffp-contract=off");
        }
        if compiler.is_like_clang() {
            simd_build.flag("-ffp-model=strict");
        }
        if compiler.is_like_msvc() {
            simd_build.flag("/fp:strict");
        }

        // Add arch-specific flags
        if compiler.is_like_clang() || compiler.is_like_gnu() {
            for flag in arch_flags.split_whitespace() {
                simd_build.flag(flag);
            }
        } else if compiler.is_like_msvc() {
            // MSVC uses /arch: flags (SSE2 is default on x64, AVX2 needs /arch:AVX2)
            if arch_flags.contains("avx2") {
                simd_build.flag("/arch:AVX2");
            }
        }

        // Copy SIMD sources to build dir and add to compilation
        for source in simd_sources {
            let source_path = opus_source_path.join(source);
            let target_path = opus_build_src_dir.join(source);
            fs::create_dir_all(target_path.parent().unwrap()).ok();
            if source_path.exists() {
                fs::copy(&source_path, &target_path).ok();
            }
            simd_build.file(&target_path);
        }

        let lib_name = format!("opus_simd_{}", i);
        simd_build.compile(&lib_name);
        println!("cargo:rustc-link-lib=static={}", lib_name);
    }

    // Link
    println!("cargo:rustc-link-lib=static=opus");
    println!(
        "cargo:rustc-link-search=native={}",
        opus_build_dir.display()
    );

    // Re-run on any changes to sources, headers, or .mk files
    for source in sources.iter().chain(headers.iter()) {
        println!(
            "cargo:rerun-if-changed={}",
            opus_source_path.join(source).display()
        );
    }
    for mk_file in &[
        "opus_sources.mk",
        "opus_headers.mk",
        "celt_sources.mk",
        "celt_headers.mk",
        "silk_sources.mk",
        "silk_headers.mk",
        "lpcnet_sources.mk",
        "lpcnet_headers.mk",
    ] {
        println!(
            "cargo:rerun-if-changed={}",
            opus_source_path.join(mk_file).display()
        );
    }
}

fn main() {
    #[cfg(feature = "generate_binding")]
    generate_binding();

    build_opus();
}
