//! Code generation tool: extracts DNN weight data from the C library and emits
//! Rust source files for each model.
//!
//! Usage:
//!   cargo run --features tools-dnn --example dnn_codegen
//!
//! This generates the following files under src/dnn/:
//!   - pitchdnn_data.rs    (deep-plc)
//!   - fargan_data.rs      (deep-plc)
//!   - plc_data.rs         (deep-plc)
//!   - dred/rdovae_enc_data.rs (dred)
//!   - dred/rdovae_dec_data.rs (dred)
//!   - osce_lace_data.rs   (osce)
//!   - osce_nolace_data.rs (osce)

use opurs::dnn::nnet::{
    parse_weights, WeightArray, WEIGHT_TYPE_FLOAT, WEIGHT_TYPE_INT, WEIGHT_TYPE_INT8,
    WEIGHT_TYPE_QWEIGHT,
};
use std::fmt::Write as FmtWrite;
use std::fs;
use std::path::Path;

/// Model descriptor for code generation.
struct ModelDesc {
    /// Rust file path relative to the crate root.
    rust_path: &'static str,
    /// C source file this was generated from.
    c_source: &'static str,
    /// Feature gate for this module (used in generated file comment).
    #[allow(dead_code)]
    feature: &'static str,
    /// Function name for the public array accessor.
    fn_name: &'static str,
    /// FFI function to get blob size.
    ffi_size: unsafe extern "C" fn() -> i32,
    /// FFI function to write blob.
    ffi_write: unsafe extern "C" fn(*mut u8) -> i32,
}

fn get_model_blob(desc: &ModelDesc) -> Vec<u8> {
    unsafe {
        let size = (desc.ffi_size)() as usize;
        let mut buf = vec![0u8; size];
        let written = (desc.ffi_write)(buf.as_mut_ptr()) as usize;
        assert_eq!(size, written, "blob size mismatch for {}", desc.rust_path);
        buf
    }
}

fn type_name(type_id: i32) -> &'static str {
    match type_id {
        WEIGHT_TYPE_FLOAT => "WEIGHT_TYPE_FLOAT",
        WEIGHT_TYPE_INT => "WEIGHT_TYPE_INT",
        WEIGHT_TYPE_QWEIGHT => "WEIGHT_TYPE_QWEIGHT",
        WEIGHT_TYPE_INT8 => "WEIGHT_TYPE_INT8",
        _ => panic!("unknown weight type: {type_id}"),
    }
}

/// Format a byte slice as a Rust static array literal.
fn format_byte_array(data: &[u8]) -> String {
    let mut out = String::new();
    for (i, chunk) in data.chunks(16).enumerate() {
        if i > 0 {
            out.push('\n');
        }
        out.push_str("    ");
        for (j, b) in chunk.iter().enumerate() {
            if j > 0 {
                out.push_str(", ");
            }
            write!(out, "0x{b:02x}").unwrap();
        }
        out.push(',');
    }
    out
}

/// Emit a Rust source file for one model.
fn emit_rust_file(desc: &ModelDesc, arrays: &[WeightArray], crate_root: &Path) {
    let mut src = String::new();

    writeln!(
        src,
        "//! Auto-generated from upstream C: dnn/{c_source}\n\
         //! Generated by: cargo run --features tools-dnn --example dnn_codegen\n\
         //!\n\
         //! DO NOT EDIT — regenerate with the command above.\n",
        c_source = desc.c_source,
    )
    .unwrap();

    writeln!(
        src,
        "use crate::dnn::nnet::{{WeightArray, {types}}};",
        types = {
            let mut types = Vec::new();
            for a in arrays {
                let tn = type_name(a.type_id);
                if !types.contains(&tn) {
                    types.push(tn);
                }
            }
            types.join(", ")
        }
    )
    .unwrap();
    writeln!(src).unwrap();

    // Emit each weight array as a static byte slice.
    for array in arrays {
        let const_name = array.name.to_uppercase();
        writeln!(
            src,
            "static {const_name}: &[u8] = &[\n{data}\n];",
            data = format_byte_array(&array.data[..array.size]),
        )
        .unwrap();
        writeln!(src).unwrap();
    }

    // Emit the public accessor function.
    writeln!(
        src,
        "/// Return all weight arrays for this model.\n\
         pub fn {fn_name}() -> Vec<WeightArray> {{\n    vec![",
        fn_name = desc.fn_name,
    )
    .unwrap();
    for array in arrays {
        let const_name = array.name.to_uppercase();
        writeln!(
            src,
            "        WeightArray {{\n\
             {i}    name: \"{name}\".into(),\n\
             {i}    type_id: {type_id},\n\
             {i}    size: {size},\n\
             {i}    data: {const_name}.to_vec(),\n\
             {i}}},",
            i = "    ",
            name = array.name,
            type_id = type_name(array.type_id),
            size = array.size,
        )
        .unwrap();
    }
    writeln!(src, "    ]\n}}").unwrap();

    let out_path = crate_root.join(desc.rust_path);
    if let Some(parent) = out_path.parent() {
        fs::create_dir_all(parent).unwrap();
    }
    fs::write(&out_path, src).unwrap();

    let total_bytes: usize = arrays.iter().map(|a| a.size).sum();
    println!(
        "  {} — {} arrays, {:.1} KB",
        desc.rust_path,
        arrays.len(),
        total_bytes as f64 / 1024.0,
    );
}

fn main() {
    let crate_root = Path::new(env!("CARGO_MANIFEST_DIR"));

    let models: Vec<ModelDesc> = vec![
        ModelDesc {
            rust_path: "src/dnn/pitchdnn_data.rs",
            c_source: "pitchdnn_data.c",
            feature: "deep-plc",
            fn_name: "pitchdnn_arrays",
            ffi_size: libopus_sys::opus_dnn_pitchdnn_blob_size,
            ffi_write: libopus_sys::opus_dnn_pitchdnn_write,
        },
        ModelDesc {
            rust_path: "src/dnn/fargan_data.rs",
            c_source: "fargan_data.c",
            feature: "deep-plc",
            fn_name: "fargan_arrays",
            ffi_size: libopus_sys::opus_dnn_fargan_blob_size,
            ffi_write: libopus_sys::opus_dnn_fargan_write,
        },
        ModelDesc {
            rust_path: "src/dnn/plc_data.rs",
            c_source: "plc_data.c",
            feature: "deep-plc",
            fn_name: "plcmodel_arrays",
            ffi_size: libopus_sys::opus_dnn_plcmodel_blob_size,
            ffi_write: libopus_sys::opus_dnn_plcmodel_write,
        },
        ModelDesc {
            rust_path: "src/dnn/dred/rdovae_enc_data.rs",
            c_source: "dred_rdovae_enc_data.c",
            feature: "dred",
            fn_name: "rdovaeenc_arrays",
            ffi_size: libopus_sys::opus_dnn_rdovaeenc_blob_size,
            ffi_write: libopus_sys::opus_dnn_rdovaeenc_write,
        },
        ModelDesc {
            rust_path: "src/dnn/dred/rdovae_dec_data.rs",
            c_source: "dred_rdovae_dec_data.c",
            feature: "dred",
            fn_name: "rdovaedec_arrays",
            ffi_size: libopus_sys::opus_dnn_rdovaedec_blob_size,
            ffi_write: libopus_sys::opus_dnn_rdovaedec_write,
        },
        ModelDesc {
            rust_path: "src/dnn/osce_lace_data.rs",
            c_source: "lace_data.c",
            feature: "osce",
            fn_name: "lacelayers_arrays",
            ffi_size: libopus_sys::opus_dnn_lace_blob_size,
            ffi_write: libopus_sys::opus_dnn_lace_write,
        },
        ModelDesc {
            rust_path: "src/dnn/osce_nolace_data.rs",
            c_source: "nolace_data.c",
            feature: "osce",
            fn_name: "nolacelayers_arrays",
            ffi_size: libopus_sys::opus_dnn_nolace_blob_size,
            ffi_write: libopus_sys::opus_dnn_nolace_write,
        },
        ModelDesc {
            rust_path: "src/dnn/bbwenet_data.rs",
            c_source: "bbwenet_data.c",
            feature: "osce",
            fn_name: "bbwenetlayers_arrays",
            ffi_size: libopus_sys::opus_dnn_bbwenet_blob_size,
            ffi_write: libopus_sys::opus_dnn_bbwenet_write,
        },
    ];

    println!("Generating DNN weight data files from upstream C library...\n");

    for desc in &models {
        let blob = get_model_blob(desc);
        let arrays = parse_weights(&blob).unwrap_or_else(|| {
            panic!("Failed to parse weight blob for {}", desc.rust_path);
        });
        emit_rust_file(desc, &arrays, crate_root);
    }

    println!("\nDone. Remember to wire the new modules in src/dnn/mod.rs.");
}
